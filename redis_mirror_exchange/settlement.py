"""
Redis Mirror CE Exchange Settlement Manager

This module provides functionality for Exchange to generate settlement reports,
manage the settlement process, and process settlement confirmations from WSPs.
"""

import time
import logging
import json
from typing import Dict, Any, Optional, List, Callable, Union, Tuple

from sdk_ce.redis_mirror_core import (
    RedisConnectionManager,
    KeyManager,
    StreamProcessor,
    StreamPublisher,
    RedisMirrorError,
    ValidationError,
    TimeoutError
)
from .credit import CreditInventoryManager

# Configure logging
logger = logging.getLogger(__name__)


class SettlementReport:
    """
    Represents a settlement report generated by the Exchange.
    
    This class encapsulates the data and state of a settlement report.
    """
    
    STATUS_PENDING = "pending"
    STATUS_PROCESSING = "processing"
    STATUS_COMPLETED = "completed"
    STATUS_FAILED = "failed"
    
    def __init__(
        self,
        report_id: str,
        user_id: str,
        timestamp: int,
        eod_time: str,
        assets_bought: List[Dict[str, Any]],
        assets_sold: List[Dict[str, Any]],
        net_position: Dict[str, str],
        settlement_instructions: Dict[str, str]
    ):
        """
        Initialize a settlement report.
        
        Args:
            report_id: Settlement report identifier
            user_id: User identifier
            timestamp: Report timestamp
            eod_time: End-of-day time
            assets_bought: List of assets bought
            assets_sold: List of assets sold
            net_position: Net position for each asset
            settlement_instructions: Settlement instructions
        """
        self.report_id = report_id
        self.user_id = user_id
        self.timestamp = timestamp
        self.eod_time = eod_time
        self.assets_bought = assets_bought
        self.assets_sold = assets_sold
        self.net_position = net_position
        self.settlement_instructions = settlement_instructions
        self.status = self.STATUS_PENDING
        self.processing_timestamp = None
        self.completion_timestamp = None
        self.failure_reason = None
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the settlement report to a dictionary.
        
        Returns:
            Dictionary representation of the settlement report
        """
        return {
            "report_id": self.report_id,
            "user_id": self.user_id,
            "timestamp": self.timestamp,
            "eod_time": self.eod_time,
            "assets_bought": self.assets_bought,
            "assets_sold": self.assets_sold,
            "net_position": self.net_position,
            "settlement_instructions": self.settlement_instructions,
            "status": self.status,
            "processing_timestamp": self.processing_timestamp,
            "completion_timestamp": self.completion_timestamp,
            "failure_reason": self.failure_reason
        }
    
    def to_stream_data(self) -> Dict[str, str]:
        """
        Convert the settlement report to stream data.
        
        Returns:
            Stream data dictionary
        """
        # Create settlement data
        settlement_data = {
            "user_id": self.user_id,
            "eod_time": self.eod_time,
            "assets": {
                "bought": self.assets_bought,
                "sold": self.assets_sold
            },
            "net_position": self.net_position,
            "settlement_instructions": self.settlement_instructions
        }
        
        # Create stream data
        return {
            "type": "settlement",
            "report_id": self.report_id,
            "timestamp": str(self.timestamp),
            "data": json.dumps(settlement_data)
        }
    
    def mark_processing(self):
        """Mark the settlement report as processing."""
        self.status = self.STATUS_PROCESSING
        self.processing_timestamp = int(time.time())
    
    def mark_completed(self):
        """Mark the settlement report as completed."""
        self.status = self.STATUS_COMPLETED
        self.completion_timestamp = int(time.time())
    
    def mark_failed(self, reason: str):
        """
        Mark the settlement report as failed.
        
        Args:
            reason: Failure reason
        """
        self.status = self.STATUS_FAILED
        self.failure_reason = reason
        self.completion_timestamp = int(time.time())
    
    def is_pending(self) -> bool:
        """
        Check if the settlement report is pending.
        
        Returns:
            True if the settlement report is pending, False otherwise
        """
        return self.status == self.STATUS_PENDING
    
    def is_processing(self) -> bool:
        """
        Check if the settlement report is processing.
        
        Returns:
            True if the settlement report is processing, False otherwise
        """
        return self.status == self.STATUS_PROCESSING
    
    def is_completed(self) -> bool:
        """
        Check if the settlement report is completed.
        
        Returns:
            True if the settlement report is completed, False otherwise
        """
        return self.status == self.STATUS_COMPLETED
    
    def is_failed(self) -> bool:
        """
        Check if the settlement report is failed.
        
        Returns:
            True if the settlement report is failed, False otherwise
        """
        return self.status == self.STATUS_FAILED
    
    def __str__(self) -> str:
        """String representation of the settlement report."""
        return (f"SettlementReport(id={self.report_id}, user={self.user_id}, "
                f"status={self.status})")


class SettlementConfirmation:
    """
    Represents a settlement confirmation from a WSP.
    
    This class encapsulates the data and state of a settlement confirmation.
    """
    
    def __init__(
        self,
        settlement_id: str,
        user_id: str,
        timestamp: int,
        status: str,
        details: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize a settlement confirmation.
        
        Args:
            settlement_id: Settlement identifier
            user_id: User identifier
            timestamp: Confirmation timestamp
            status: Confirmation status
            details: Optional confirmation details
        """
        self.settlement_id = settlement_id
        self.user_id = user_id
        self.timestamp = timestamp
        self.status = status
        self.details = details or {}
    
    @classmethod
    def from_stream_data(cls, data: Dict[str, str]) -> 'SettlementConfirmation':
        """
        Create a settlement confirmation from stream data.
        
        Args:
            data: Stream data dictionary
            
        Returns:
            Settlement confirmation instance
            
        Raises:
            ValidationError: If the data is invalid
        """
        try:
            # Extract required fields
            settlement_id = data.get("settlement_id")
            user_id = data.get("user_id")
            timestamp = int(data.get("timestamp", str(int(time.time()))))
            status = data.get("status")
            
            # Extract optional fields
            details = None
            if "details" in data:
                details = json.loads(data.get("details", "{}"))
            
            # Validate required fields
            if not settlement_id:
                raise ValidationError("Settlement confirmation is missing settlement_id")
            
            if not user_id:
                raise ValidationError("Settlement confirmation is missing user_id")
            
            if not status:
                raise ValidationError("Settlement confirmation is missing status")
            
            # Create settlement confirmation
            return cls(
                settlement_id=settlement_id,
                user_id=user_id,
                timestamp=timestamp,
                status=status,
                details=details
            )
        except (json.JSONDecodeError, ValueError) as e:
            raise ValidationError(f"Invalid settlement confirmation data: {e}")
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the settlement confirmation to a dictionary.
        
        Returns:
            Dictionary representation of the settlement confirmation
        """
        return {
            "settlement_id": self.settlement_id,
            "user_id": self.user_id,
            "timestamp": self.timestamp,
            "status": self.status,
            "details": self.details
        }
    
    def __str__(self) -> str:
        """String representation of the settlement confirmation."""
        return (f"SettlementConfirmation(id={self.settlement_id}, user={self.user_id}, "
                f"status={self.status})")


class SettlementManager:
    """
    Handles settlement operations for Exchanges.
    
    This class generates settlement reports, manages the settlement process,
    and processes settlement confirmations from WSPs.
    """
    
    def __init__(
        self,
        connection_manager: RedisConnectionManager,
        inventory_manager: Optional[CreditInventoryManager] = None,
        auto_start_processor: bool = True
    ):
        """
        Initialize the settlement manager.
        
        Args:
            connection_manager: Redis connection manager
            inventory_manager: Optional credit inventory manager
            auto_start_processor: Whether to automatically start the confirmation processor
        """
        self.connection_manager = connection_manager
        
        # Get Redis clients
        self.wsp_client = connection_manager.get_wsp_client()
        self.replica_client = connection_manager.get_replica_client()
        
        # Create inventory manager if not provided
        if inventory_manager is None:
            self.inventory_manager = CreditInventoryManager(self.wsp_client)
        else:
            self.inventory_manager = inventory_manager
        
        # Create stream publisher for settlement reports
        self.settlement_stream = KeyManager.settlement_report_stream()
        self.publisher = StreamPublisher(self.replica_client, self.settlement_stream)
        
        # Create stream processor for settlement confirmations
        self.confirmation_stream = KeyManager.settlement_confirmation_stream()
        self.processor = StreamProcessor(
            self.replica_client,
            self.confirmation_stream,
            "settlement-manager",
            auto_create_group=True
        )
        
        # Settlement reports dictionary (report_id -> SettlementReport)
        self.settlement_reports = {}
        
        # Settlement confirmations dictionary (settlement_id -> SettlementConfirmation)
        self.settlement_confirmations = {}
        
        # Settlement callbacks
        self.confirmation_callbacks = []
        
        # Start confirmation processor if auto_start is enabled
        self._processor_running = False
        if auto_start_processor:
            self.start_confirmation_processor()
        
        logger.info("Settlement Manager initialized")
    
    def start_confirmation_processor(self):
        """Start the settlement confirmation processor."""
        if self._processor_running:
            return
        
        self._processor_running = True
        
        # Start processing in a separate thread
        import threading
        thread = threading.Thread(
            target=self._process_settlement_confirmations,
            daemon=True
        )
        thread.start()
        
        logger.info("Settlement confirmation processor started")
    
    def stop_confirmation_processor(self):
        """Stop the settlement confirmation processor."""
        self._processor_running = False
        logger.info("Settlement confirmation processor stopped")
    
    def add_confirmation_callback(self, callback: Callable[[SettlementConfirmation], None]):
        """
        Add a callback for settlement confirmations.
        
        The callback will be called with the settlement confirmation when a confirmation is received.
        
        Args:
            callback: Callback function that takes a SettlementConfirmation as its argument
        """
        self.confirmation_callbacks.append(callback)
        logger.debug("Settlement confirmation callback added")
    
    def generate_settlement_report(
        self,
        user_id: str,
        assets_bought: List[Dict[str, Any]],
        assets_sold: List[Dict[str, Any]],
        net_position: Dict[str, str],
        settlement_instructions: Dict[str, str],
        eod_time: Optional[str] = None,
        publish: bool = True
    ) -> SettlementReport:
        """
        Generate a settlement report for a user.
        
        Args:
            user_id: User identifier
            assets_bought: List of assets bought
            assets_sold: List of assets sold
            net_position: Net position for each asset
            settlement_instructions: Settlement instructions
            eod_time: Optional end-of-day time (defaults to current time in ISO format)
            publish: Whether to publish the report to the settlement stream
            
        Returns:
            Generated settlement report
        """
        logger.info(f"Generating settlement report for user: {user_id}")
        
        # Generate report ID
        timestamp = int(time.time())
        report_id = f"settlement-{timestamp}-{user_id}"
        
        # Use current time as EOD time if not provided
        if eod_time is None:
            from datetime import datetime
            eod_time = datetime.utcnow().isoformat() + "Z"
        
        # Create settlement report
        report = SettlementReport(
            report_id=report_id,
            user_id=user_id,
            timestamp=timestamp,
            eod_time=eod_time,
            assets_bought=assets_bought,
            assets_sold=assets_sold,
            net_position=net_position,
            settlement_instructions=settlement_instructions
        )
        
        # Store settlement report
        self.settlement_reports[report_id] = report
        
        # Publish settlement report if requested
        if publish:
            stream_data = report.to_stream_data()
            message_id = self.publisher.publish(stream_data)
            
            if not message_id:
                logger.error(f"Failed to publish settlement report: {report_id}")
            else:
                logger.info(f"Settlement report published: {report_id}")
        
        return report
    
    def generate_settlement_reports(
        self,
        user_data: Dict[str, Dict[str, Any]],
        eod_time: Optional[str] = None,
        publish: bool = True
    ) -> List[SettlementReport]:
        """
        Generate settlement reports for multiple users.
        
        Args:
            user_data: Dictionary mapping user IDs to settlement data
            eod_time: Optional end-of-day time (defaults to current time in ISO format)
            publish: Whether to publish the reports to the settlement stream
            
        Returns:
            List of generated settlement reports
        """
        logger.info(f"Generating settlement reports for {len(user_data)} users")
        
        reports = []
        for user_id, data in user_data.items():
            try:
                # Extract settlement data
                assets_bought = data.get("assets_bought", [])
                assets_sold = data.get("assets_sold", [])
                net_position = data.get("net_position", {})
                settlement_instructions = data.get("settlement_instructions", {})
                
                # Generate settlement report
                report = self.generate_settlement_report(
                    user_id=user_id,
                    assets_bought=assets_bought,
                    assets_sold=assets_sold,
                    net_position=net_position,
                    settlement_instructions=settlement_instructions,
                    eod_time=eod_time,
                    publish=publish
                )
                
                reports.append(report)
            except Exception as e:
                logger.error(f"Error generating settlement report for user {user_id}: {e}")
        
        return reports
    
    def process_settlement_confirmations(
        self,
        callback: Optional[Callable[[SettlementConfirmation], None]] = None,
        run_once: bool = False
    ):
        """
        Process settlement confirmations from WSPs.
        
        This method can be used to manually process settlement confirmations instead of
        using the automatic processor.
        
        Args:
            callback: Optional callback function for settlement confirmations
            run_once: If True, process one batch and return; if False, run continuously
        """
        if callback:
            self.add_confirmation_callback(callback)
        
        def confirmation_handler(message):
            try:
                # Check if this is a settlement confirmation
                message_type = message.get("type")
                if message_type != "confirmation":
                    logger.debug(f"Ignoring non-confirmation message: {message_type}")
                    return True
                
                # Parse settlement confirmation
                confirmation = SettlementConfirmation.from_stream_data(message)
                
                # Store settlement confirmation
                self.settlement_confirmations[confirmation.settlement_id] = confirmation
                
                # Update settlement report status if it exists
                report = self.settlement_reports.get(confirmation.settlement_id)
                if report:
                    if confirmation.status == "completed":
                        report.mark_completed()
                    elif confirmation.status == "failed":
                        failure_reason = confirmation.details.get("failure_reason", "Unknown failure")
                        report.mark_failed(failure_reason)
                    
                    logger.info(f"Updated settlement report status: {report.status}")
                
                # Call callbacks
                for callback_fn in self.confirmation_callbacks:
                    try:
                        callback_fn(confirmation)
                    except Exception as e:
                        logger.error(f"Error in settlement confirmation callback: {e}")
                
                # Process credit inventory updates if completed
                if confirmation.status == "completed":
                    self._process_credit_inventory_updates(confirmation)
                
                return True
            except Exception as e:
                logger.error(f"Error processing settlement confirmation: {e}")
                return False
        
        # Process settlement confirmations
        if run_once:
            self.processor._process_batch(confirmation_handler, ">")
        else:
            self._processor_running = True
            while self._processor_running:
                self.processor._process_batch(confirmation_handler, ">")
                time.sleep(0.1)
    
    def _process_settlement_confirmations(self):
        """Process settlement confirmations from WSPs."""
        logger.info("Starting settlement confirmation processor")
        
        def confirmation_handler(message):
            try:
                # Check if this is a settlement confirmation
                message_type = message.get("type")
                if message_type != "confirmation":
                    logger.debug(f"Ignoring non-confirmation message: {message_type}")
                    return True
                
                # Parse settlement confirmation
                confirmation = SettlementConfirmation.from_stream_data(message)
                
                # Store settlement confirmation
                self.settlement_confirmations[confirmation.settlement_id] = confirmation
                
                # Update settlement report status if it exists
                report = self.settlement_reports.get(confirmation.settlement_id)
                if report:
                    if confirmation.status == "completed":
                        report.mark_completed()
                    elif confirmation.status == "failed":
                        failure_reason = confirmation.details.get("failure_reason", "Unknown failure")
                        report.mark_failed(failure_reason)
                    
                    logger.info(f"Updated settlement report status: {report.status}")
                
                # Call callbacks
                for callback_fn in self.confirmation_callbacks:
                    try:
                        callback_fn(confirmation)
                    except Exception as e:
                        logger.error(f"Error in settlement confirmation callback: {e}")
                
                # Process credit inventory updates if completed
                if confirmation.status == "completed":
                    self._process_credit_inventory_updates(confirmation)
                
                return True
            except Exception as e:
                logger.error(f"Error processing settlement confirmation: {e}")
                return False
        
        # Process settlement confirmations
        self.processor.process_messages(confirmation_handler)
    
    def _process_credit_inventory_updates(self, confirmation: SettlementConfirmation):
        """
        Process credit inventory updates based on settlement confirmation.
        
        This method updates the credit inventory for assets that were transferred
        during settlement.
        
        Args:
            confirmation: Settlement confirmation
        """
        logger.info(f"Processing credit inventory updates for settlement: {confirmation.settlement_id}")
        
        # Get settlement report
        report = self.settlement_reports.get(confirmation.settlement_id)
        if not report:
            logger.warning(f"Settlement report not found: {confirmation.settlement_id}")
            return
        
        # Get transferred assets from confirmation details
        assets_transferred = confirmation.details.get("assets_transferred", [])
        if not assets_transferred:
            logger.warning(f"No assets transferred in confirmation: {confirmation.settlement_id}")
            return
        
        # Process each transferred asset
        for asset_info in assets_transferred:
            try:
                asset_id = asset_info.get("asset_id")
                amount = float(asset_info.get("amount", "0"))
                
                if not asset_id or amount == 0:
                    continue
                
                # Check if this is a sold asset (decrease CI)
                is_sold = any(a.get("asset_id") == asset_id for a in report.assets_sold)
                
                if is_sold:
                    # Decrease credit inventory for sold assets
                    logger.info(f"Decreasing CI for user {report.user_id}, asset {asset_id}, amount {amount}")
                    self.inventory_manager.decrease_inventory(report.user_id, asset_id, amount)
            except Exception as e:
                logger.error(f"Error updating credit inventory for asset {asset_id}: {e}")
    
    def get_settlement_report(self, report_id: str) -> Optional[SettlementReport]:
        """
        Get a settlement report by ID.
        
        Args:
            report_id: Report identifier
            
        Returns:
            Settlement report if found, None otherwise
        """
        return self.settlement_reports.get(report_id)
    
    def get_settlement_reports(
        self,
        user_id: Optional[str] = None,
        status: Optional[str] = None
    ) -> List[SettlementReport]:
        """
        Get settlement reports.
        
        Args:
            user_id: Optional user ID to filter by
            status: Optional status to filter by
            
        Returns:
            List of settlement reports
        """
        reports = list(self.settlement_reports.values())
        
        # Filter by user ID
        if user_id:
            reports = [r for r in reports if r.user_id == user_id]
        
        # Filter by status
        if status:
            reports = [r for r in reports if r.status == status]
        
        return reports
    
    def get_settlement_confirmation(self, settlement_id: str) -> Optional[SettlementConfirmation]:
        """
        Get a settlement confirmation by ID.
        
        Args:
            settlement_id: Settlement identifier
            
        Returns:
            Settlement confirmation if found, None otherwise
        """
        return self.settlement_confirmations.get(settlement_id)
    
    def get_settlement_confirmations(
        self,
        user_id: Optional[str] = None,
        status: Optional[str] = None
    ) -> List[SettlementConfirmation]:
        """
        Get settlement confirmations.
        
        Args:
            user_id: Optional user ID to filter by
            status: Optional status to filter by
            
        Returns:
            List of settlement confirmations
        """
        confirmations = list(self.settlement_confirmations.values())
        
        # Filter by user ID
        if user_id:
            confirmations = [c for c in confirmations if c.user_id == user_id]
        
        # Filter by status
        if status:
            confirmations = [c for c in confirmations if c.status == status]
        
        return confirmations